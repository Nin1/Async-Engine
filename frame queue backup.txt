#include "FrameStageRunner.h"
#include "FrameData.h"
#include "Assert.h"
#include <Jobs/Jobs.h>
#include <atomic>
#include <iostream>

FrameStageRunner::FrameStageRunner(const char* name)
	: m_name(name)
{
	m_thisFrame.store(DUMMY_PTR);

	// Initialise frame queue

	FrameNodePtr nodePtr = AllocateFrameNode();
	FrameNode& node = *nodePtr.m_ptr;
	node.m_next.store({ nullptr, 0, -1 });

	m_queue.m_head = m_queue.m_tail = nodePtr;

}

// This should only ever be called by one thread at a time (unless the pipeline ends up branching and converging ever?
void FrameStageRunner::QueueFrame(FrameData& frame)
{
	// Get ownership of the back of the queue and increment m_queueBack
	int queueBack = m_queueBack;
	while (!std::atomic_compare_exchange_weak(
				&m_queueBack,
				&queueBack,
				((queueBack + 1) % SIMULTANEOUS_FRAMES)))
	{
		/** Empty block - compare_exchange will write m_queueBack into queueBack if the exchange failed. */
		ASSERTM(false, "More than one thread queueing a frame at once?");
	}

	// Put the frame in the queue.
	ASSERT(frame.m_active == false);
	m_queuedFrames[queueBack] = &frame;
	//std::printf("%s: Queued to index %d\n", m_name, queueBack);
	// Attempt to start this frame if nothing is running
	AttemptStartFrame();
}

bool FrameStageRunner::AttemptStartFrame()
{
	// Only continue if we have a frame queued up
	if (m_queuedFrames[m_queueFront] != nullptr)
	{
		// Atomically get the first frame in the queue (only if m_thisFrame isn't valid)
		FrameData* dummyPtr = DUMMY_PTR;
		if (std::atomic_compare_exchange_strong(
			&m_thisFrame,
			&dummyPtr,
			m_queuedFrames[m_queueFront]))
		{
			// Convenience pointer
			m_frameData = m_thisFrame.load();
			// m_frameData is sometimes null here!!! If two threads reach line 36, and one thread then processes this whole stage before the other performs the exchange, we can end up with a problem.
			// We need to get the frame at the front of the queue and prevent any other thread from attempting to do the same, without hitting the m_failures breakpoint

			// Debugging
			m_failures--;
			m_framesBeingExecuted++;
			ASSERT(m_framesBeingExecuted.load() < 2);
			ASSERT(m_frameData->m_active == false);

			// Look at next spot in queue
			m_queuedFrames[m_queueFront] = nullptr;
			m_queueFront = (m_queueFront + 1) % SIMULTANEOUS_FRAMES;

			// Debugging
			FrameData* nextFrame = m_queuedFrames[m_queueFront];
			ASSERT(nextFrame == nullptr || nextFrame->m_frameNumber == -1 || (nextFrame->m_frameNumber == m_frameData->m_frameNumber + 1))

				// Set this frame data active, with one dependency on FinishFrame so it won't run until we've updated the queue
				m_frameData->m_active = true;
			JobCounterPtr jobFinished = Jobs::GetNewJobCounter();
			jobFinished.m_counter->m_numJobs++;
			RunJob(jobFinished);

			// Remove one dependency on FinishJob
			jobFinished.m_counter->m_numJobs--;
			return true;
		}
	}
	m_failures++;
	ASSERT(m_failures.load() < SIMULTANEOUS_FRAMES);	// Hitting this implies that all attempts to run this stage have failed, and no more attempts are coming.
	return false;
}

void FrameStageRunner::RunJob(JobCounterPtr& jobFinished)
{
	RunJobInner(jobFinished);
	Jobs::CreateJobWithDependency(FinishFrame, this, jobFinished);
}

DEFINE_CLASS_JOB(FrameStageRunner, FinishFrame)
{
	// Queue frame in next stage
	ASSERT(m_nextStage != nullptr);
	m_frameData->m_active = false;
	m_nextStage->QueueFrame(*m_frameData);

	// Attempt to start our next queued frame if we have one
	m_frameData = nullptr;
	m_framesBeingExecuted--;
	m_thisFrame.store(DUMMY_PTR);
	AttemptStartFrame();

}

FrameStageRunner::FrameNodePtr FrameStageRunner::AllocateFrameNode()
{
	constexpr char IN_USE = 1;
	constexpr char NOT_IN_USE = 0;

	int index = 0;
	// Lock until we get a node
	while (_InterlockedCompareExchange8(&m_freeListInUse[index], IN_USE, NOT_IN_USE) == IN_USE)
	{
		index = (index + 1) % SIMULTANEOUS_FRAMES;
	}
	// Return the node
	return { &m_freeList[index], 0, index };
}

void FrameStageRunner::DeallocateFrameNode(int index)
{
	constexpr char IN_USE = 1;
	constexpr char NOT_IN_USE = 0;
	m_freeListInUse[index] = NOT_IN_USE;
}

void FrameStageRunner::EnqueueFrame(FrameData& frame)
{
	// Allocate node from free list
	FrameNodePtr nodePtr = AllocateFrameNode();
	FrameNode& node = *nodePtr.m_ptr;
	node.m_frame = &frame;
	node.m_next.store({ nullptr, 0 });

	while (true)
	{
		// Load tail
		FrameNodePtr tail = m_queue.m_tail;
		FrameNodePtr next = tail.m_ptr->m_next;
		// Check tail is consistent
		if (tail == m_queue.m_tail)
		{
			// Was tail pointing to the last node?
			if (next.m_ptr == nullptr)
			{
				// Try to link the new node to the end of the list
				if (std::atomic_compare_exchange_strong(
					&(tail.m_ptr->m_next),
					&next,
					{ &node, next.m_count + 1, nodePtr.m_index }))
				{
					// Enqueue successful - Try to point tail to the inserted node
					std::atomic_compare_exchange_strong(
						&(m_queue.m_tail),
						&tail,
						{ &node, tail.m_count + 1, nodePtr.m_index });

					break;
				}
			}
			else
			{
				// Tail wasn't pointing to the last node - try and correct it
				std::atomic_compare_exchange_strong(
					&(m_queue.m_tail),
					&tail,
					{ next.m_ptr, tail.m_count + 1, next.m_index });
			}
		}
	}
}

bool FrameStageRunner::DequeueFrame(FrameData* frameOut)
{
	while (true)
	{
		// Load relevant pointers
		FrameNodePtr head = m_queue.m_head;
		FrameNodePtr tail = m_queue.m_tail;
		FrameNodePtr next = head.m_ptr->m_next;
		// Is head consistent?
		if (head == m_queue.m_head)
		{
			// Is queue empty?
			if (head.m_ptr == tail.m_ptr)
			{
				if (next.m_ptr == nullptr)
				{
					// Queue is empty
					return false;
				}
				// Tail wasn't pointing to last node - try to correct it
				std::atomic_compare_exchange_strong(
					&(m_queue.m_tail),
					&tail,
					{ next.m_ptr, tail.m_count + 1, next.m_index });
			}
			else
			{
				// Read value from next before moving on
				frameOut = next.m_ptr->m_frame;
				// Try to move head to next node
				if (std::atomic_compare_exchange_strong(
					&(m_queue.m_head),
					&head,
					{ next.m_ptr, head.m_count + 1, next.m_index }))
				{
					// Dequeue successful - Free head
					if (head.m_index >= 0)
					{
						DeallocateFrameNode(head.m_index);
					}
					break;
				}
			}
		}
	}
	return true;
}

